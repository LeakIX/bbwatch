package vulnerability_source

import (
	"fmt"
	"github.com/LeakIX/LeakIXClient"
	"github.com/LeakIX/bbwatch/program_sources"
	"strings"
	"time"
)

func init() {
	VulnerabilitySources["leakix"] = &LeakIXSource{}
}

type LeakIXSource struct {
	ApiKey         string
	ExcludePlugins []string
}

func (ls *LeakIXSource) GetName() string {
	return "LeakIX"
}

func (ls *LeakIXSource) Configure(config map[string]interface{}) {
	for configKey, configValue := range config {
		switch configKey {
		case "api_key":
			ls.ApiKey = configValue.(string)
		case "exclude_plugins":
			for _, iConfigValue := range configValue.([]interface{}) {
				ls.ExcludePlugins = append(ls.ExcludePlugins, iConfigValue.(string))
			}
		default:
			continue
		}
	}
	return
}

func (ls *LeakIXSource) GetVulnerabilities(program program_sources.Program) []Vulnerability {
	var query string
	var vulnerabilities []Vulnerability
	for _, scope := range program.Assets {
		query += fmt.Sprintf("host:\"%s\" ", strings.Replace(scope.Domain, "*.", "", 1))
	}
	update_date := time.Now().Add(-24 * 31 * time.Hour)
	query = fmt.Sprintf("+(%s) +update_date:>%s", query, update_date.Format("2006-01-02"))
	for _, excludePlugin := range ls.ExcludePlugins {
		query += fmt.Sprintf(" -plugin:%s", excludePlugin)
	}
	lkxSearch := LeakIXClient.SearchResultsClient{
		Scope:  "leak",
		ApiKey: ls.ApiKey,
		Query:  query,
	}
	for lkxSearch.Next() {
		severity := lkxSearch.SearchResult().Leak.Severity
		if severity == "" {
			severity = "low"
		}
		vulnerabilities = append(vulnerabilities, Vulnerability{
			Identifier: lkxSearch.SearchResult().EventSource,
			Severity:   severity,
			Resource:   lkxSearch.SearchResult().Host,
		})
	}
	return vulnerabilities
}
